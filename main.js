/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnnotationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var COMMENT_REGEX = /<span class="ob-comment(?:\s+([\w-]+))?" data-note="([\s\S]*?)">([\s\S]*?)<\/span>/g;
var DEFAULT_COLOR = "";
var STRINGS = {
  en: {
    settingLanguageName: "Language",
    settingLanguageDesc: "Choose plugin UI language (default: English).",
    settingLanguageEn: "English",
    settingLanguageZh: "Simplified Chinese",
    colorRed: "Red",
    colorDefault: "Orange (default)",
    colorYellow: "Yellow",
    colorGreen: "Green",
    colorCyan: "Cyan",
    colorBlue: "Blue",
    colorPurple: "Purple",
    colorGray: "Gray",
    cmdAddDefault: "Add Annotation (Default)",
    cmdAddWithColor: (color) => `Add Annotation (${color})`,
    cmdToggleVisibility: "Show/Hide Annotation Styles",
    cmdEditCurrent: "Edit Current Annotation",
    cmdDeleteCurrent: "Delete Current Annotation",
    cmdNormalizeCurrent: "Fix Current File Annotation data-note",
    cmdNormalizeVault: "Fix All Markdown Annotation data-note",
    noticeHidden: "Annotation styles are now hidden",
    noticeShown: "Annotation styles are now visible",
    noticeNoAnnotation: "No annotation at cursor",
    noticeNeedSelection: "Please select some text first",
    noticeNoNested: "Nested annotations are not supported; remove the old one first",
    noticeNoFixNeeded: "No annotations need fixing",
    noticeFixedCurrent: "Annotations in this file are now safe-formatted",
    noticeScanStart: "Scanning vault, please wait...",
    noticeFixedVault: (count) => `Successfully fixed annotations in ${count} Markdown file(s)`,
    noticeNeedSelectionAdd: "Please select text to add a new annotation",
    noticeCopied: "Annotations copied to clipboard!",
    noticeOpenDoc: "Please open a Markdown document first",
    ctxAdd: "Add Annotation",
    ctxEdit: "Edit Annotation",
    ctxChangeColor: " - Change Color",
    ctxDelete: "Delete Annotation",
    modalTitleEdit: "Edit Annotation",
    modalTitleNew: "Enter Annotation Content",
    modalColorLabel: "Annotation Color",
    modalKeyHint: "Enter: submit annotation; Shift+Enter: newline",
    modalCancel: "Cancel",
    modalConfirm: "Confirm",
    modalColorCurrent: "Current color: ",
    batchTitle: "\u26A0\uFE0F Batch Fix Confirmation",
    batchSummary: (count) => `Found ${count} file(s) with legacy or unsafe annotations.`,
    batchWarning: "Fixing will update HTML (data-note escaping). Please backup your vault first.",
    batchConfirm: (count) => `Confirm fix (${count} files)`,
    batchCancel: "Cancel",
    settingsGeneral: "General Settings",
    settingsAppearance: "Appearance",
    settingsInteraction: "Interaction",
    settingsAdvanced: "Advanced & Maintenance",
    settingDefaultColorName: "Default annotation color",
    settingDefaultColorDesc: "Initial color when creating a new annotation.",
    settingHideDefaultName: "Hide annotations by default",
    settingHideDefaultDesc: "On app launch, hide all annotation styling for a clean reading mode.",
    settingUnderlineName: "Show underline",
    settingUnderlineDesc: "Add a colored underline to annotated text.",
    settingBackgroundName: "Show background highlight",
    settingBackgroundDesc: "Add a translucent background highlight to annotated text.",
    settingIconName: "Show end icon",
    settingIconDesc: 'Append a small "\u{1F4DD}" icon (pseudo-element) to annotated text.',
    settingIconTriggerName: "End icon trigger",
    settingIconTriggerDesc: "Only in icon-only mode: show tooltip on hover, or require click first.",
    settingIconHover: "Hover to show",
    settingIconClick: "Click to show",
    settingLightOpacityName: "Light theme opacity",
    settingLightOpacityDesc: "Adjust highlight depth for Light themes (0% - 100%).",
    settingDarkOpacityName: "Dark theme opacity",
    settingDarkOpacityDesc: "Adjust highlight depth for Dark themes (0% - 100%).",
    settingTooltipWidthName: "Tooltip max width",
    settingTooltipWidthDesc: "Limit tooltip width (px).",
    settingFontAdjustName: "Adjust font size",
    settingFontAdjustDescPrefix: "Adjust annotation font by steps (max \xB13). Current: ",
    settingFontStepDefault: "Default",
    settingFontStep: (step) => `${step > 0 ? "+" : ""}${step} step`,
    settingFontStepPlural: (step) => `${step > 0 ? "+" : ""}${step} steps`,
    settingFontSmaller: "Smaller",
    settingFontLarger: "Larger",
    settingMarkdownName: "Enable Markdown rendering",
    settingMarkdownDesc: "Render annotation content as Markdown. Off = show plain text.",
    settingFixDataName: "One-click repair",
    settingFixDataDesc: "Scan all files and fix legacy annotation format issues.",
    settingFixDataButton: "Start scan & fix",
    settingExportName: "Export annotations (current file)",
    settingExportDesc: "Extract all annotations from the current document to clipboard.",
    settingExportButton: "Copy to clipboard",
    exportHeading: "## Annotations Export\n\n",
    exportOriginal: "Original",
    exportAnnotation: "Annotation",
    menuAddTitle: "Add Annotation"
  },
  zh: {
    settingLanguageName: "\u8BED\u8A00",
    settingLanguageDesc: "\u9009\u62E9\u63D2\u4EF6\u754C\u9762\u8BED\u8A00\uFF08\u9ED8\u8BA4\uFF1A\u82F1\u6587\uFF09\u3002",
    settingLanguageEn: "\u82F1\u8BED",
    settingLanguageZh: "\u7B80\u4F53\u4E2D\u6587",
    colorRed: "\u7EA2\u8272",
    colorDefault: "\u6A59\u8272\uFF08\u9ED8\u8BA4\uFF09",
    colorYellow: "\u9EC4\u8272",
    colorGreen: "\u7EFF\u8272",
    colorCyan: "\u9752\u8272",
    colorBlue: "\u84DD\u8272",
    colorPurple: "\u7D2B\u8272",
    colorGray: "\u7070\u8272",
    cmdAddDefault: "\u6DFB\u52A0\u6279\u6CE8\uFF08\u9ED8\u8BA4\uFF09",
    cmdAddWithColor: (color) => `\u6DFB\u52A0\u6279\u6CE8\uFF08${color}\uFF09`,
    cmdToggleVisibility: "\u663E\u793A/\u9690\u85CF\u6279\u6CE8\u6837\u5F0F",
    cmdEditCurrent: "\u7F16\u8F91\u5F53\u524D\u6279\u6CE8",
    cmdDeleteCurrent: "\u5220\u9664\u5F53\u524D\u6279\u6CE8",
    cmdNormalizeCurrent: "\u4FEE\u590D\u5F53\u524D\u6587\u4EF6\u7684\u6279\u6CE8 data-note",
    cmdNormalizeVault: "\u4FEE\u590D\u6240\u6709 Markdown \u6587\u4EF6\u7684\u6279\u6CE8 data-note",
    noticeHidden: "\u6279\u6CE8\u6837\u5F0F\u5DF2\u9690\u85CF",
    noticeShown: "\u6279\u6CE8\u6837\u5F0F\u5DF2\u663E\u793A",
    noticeNoAnnotation: "\u5149\u6807\u5904\u6CA1\u6709\u6279\u6CE8",
    noticeNeedSelection: "\u8BF7\u5148\u9009\u62E9\u4E00\u6BB5\u6587\u672C",
    noticeNoNested: "\u4E0D\u652F\u6301\u5728\u5DF2\u6709\u6279\u6CE8\u4E0A\u5D4C\u5957\u6279\u6CE8\uFF0C\u8BF7\u5148\u5220\u9664\u65E7\u6279\u6CE8",
    noticeNoFixNeeded: "\u672A\u53D1\u73B0\u9700\u8981\u4FEE\u590D\u7684\u6279\u6CE8",
    noticeFixedCurrent: "\u5F53\u524D\u6587\u4EF6\u7684\u6279\u6CE8\u5DF2\u8F6C\u6362\u4E3A\u5B89\u5168\u683C\u5F0F",
    noticeScanStart: "\u5F00\u59CB\u626B\u63CF\u5E93\u6587\u4EF6\uFF0C\u8BF7\u7A0D\u5019...",
    noticeFixedVault: (count) => `\u5DF2\u6210\u529F\u4FEE\u590D ${count} \u4E2A Markdown \u6587\u4EF6\u7684\u6279\u6CE8`,
    noticeNeedSelectionAdd: "\u8BF7\u5148\u9009\u62E9\u6587\u672C\u4EE5\u6DFB\u52A0\u65B0\u6279\u6CE8",
    noticeCopied: "\u6279\u6CE8\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01",
    noticeOpenDoc: "\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u6587\u6863",
    ctxAdd: "\u6DFB\u52A0\u6279\u6CE8",
    ctxEdit: "\u7F16\u8F91\u6279\u6CE8",
    ctxChangeColor: " - \u4FEE\u6539\u989C\u8272",
    ctxDelete: "\u5220\u9664\u6279\u6CE8",
    modalTitleEdit: "\u7F16\u8F91\u6279\u6CE8",
    modalTitleNew: "\u8F93\u5165\u6279\u6CE8\u5185\u5BB9",
    modalColorLabel: "\u6279\u6CE8\u989C\u8272",
    modalKeyHint: "Enter\uFF1A\u5B8C\u6210\u6279\u6CE8\uFF1BShift+Enter\uFF1A\u6362\u884C",
    modalCancel: "\u53D6\u6D88",
    modalConfirm: "\u786E\u5B9A",
    modalColorCurrent: "\u5F53\u524D\u989C\u8272\uFF1A",
    batchTitle: "\u26A0\uFE0F \u6279\u91CF\u4FEE\u590D\u786E\u8BA4",
    batchSummary: (count) => `\u626B\u63CF\u53D1\u73B0\u5171\u6709 ${count} \u4E2A\u6587\u4EF6\u5305\u542B\u65E7\u683C\u5F0F\u6216\u9700\u8981\u89C4\u8303\u5316\u7684\u6279\u6CE8\u3002`,
    batchWarning: "\u6267\u884C\u4FEE\u590D\u5C06\u66F4\u65B0\u8FD9\u4E9B\u6587\u4EF6\u4E2D\u7684 HTML \u7ED3\u6784\uFF08\u4E3B\u8981\u662F data-note \u7684\u5B89\u5168\u8F6C\u4E49\uFF09\u3002\u5EFA\u8BAE\u5148\u5907\u4EFD Vault\u3002",
    batchConfirm: (count) => `\u786E\u8BA4\u4FEE\u590D\uFF08${count} \u4E2A\u6587\u4EF6\uFF09`,
    batchCancel: "\u53D6\u6D88",
    settingsGeneral: "\u57FA\u7840\u8BBE\u7F6E",
    settingsAppearance: "\u5916\u89C2\u6837\u5F0F",
    settingsInteraction: "\u4EA4\u4E92\u4F53\u9A8C",
    settingsAdvanced: "\u9AD8\u7EA7\u4E0E\u7EF4\u62A4",
    settingDefaultColorName: "\u9ED8\u8BA4\u6279\u6CE8\u989C\u8272",
    settingDefaultColorDesc: "\u65B0\u5EFA\u6279\u6CE8\u65F6\u7684\u521D\u59CB\u9009\u4E2D\u989C\u8272\u3002",
    settingHideDefaultName: "\u9ED8\u8BA4\u9690\u85CF\u6279\u6CE8",
    settingHideDefaultDesc: "Obsidian \u542F\u52A8\u65F6\u81EA\u52A8\u9690\u85CF\u6240\u6709\u6279\u6CE8\u6837\u5F0F\uFF08\u7EAF\u51C0\u9605\u8BFB\u6A21\u5F0F\uFF09\u3002",
    settingUnderlineName: "\u663E\u793A\u4E0B\u5212\u7EBF",
    settingUnderlineDesc: "\u4E3A\u6279\u6CE8\u6587\u672C\u6DFB\u52A0\u5E95\u90E8\u5F69\u8272\u4E0B\u5212\u7EBF\u3002",
    settingBackgroundName: "\u663E\u793A\u80CC\u666F\u8272",
    settingBackgroundDesc: "\u4E3A\u6279\u6CE8\u6587\u672C\u6DFB\u52A0\u534A\u900F\u660E\u80CC\u666F\u9AD8\u4EAE\u3002",
    settingIconName: "\u663E\u793A\u6587\u672B\u56FE\u6807",
    settingIconDesc: "\u5728\u6279\u6CE8\u6587\u672C\u672B\u5C3E\u8FFD\u52A0\u4E00\u4E2A\u5C0F\u7684\u201C\u{1F4DD}\u201D\u56FE\u6807\uFF08\u4F2A\u5143\u7D20\uFF09\u3002",
    settingIconTriggerName: "\u6587\u672B\u56FE\u6807\u89E6\u53D1\u65B9\u5F0F",
    settingIconTriggerDesc: "\u4EC5\u5728\u201C\u4EC5\u56FE\u6807\u201D\u6A21\u5F0F\u4E0B\u751F\u6548\uFF1A\u60AC\u6D6E\u81EA\u52A8\u663E\u793A\u6216\u9700\u70B9\u51FB\u540E\u663E\u793A\u6279\u6CE8\u3002",
    settingIconHover: "\u79FB\u52A8\u5230\u56FE\u6807\u81EA\u52A8\u60AC\u6D6E",
    settingIconClick: "\u70B9\u51FB\u56FE\u6807\u540E\u518D\u60AC\u6D6E",
    settingLightOpacityName: "\u6D45\u8272\u6A21\u5F0F\u4E0D\u900F\u660E\u5EA6",
    settingLightOpacityDesc: "\u8C03\u6574 Light \u4E3B\u9898\u4E0B\u9AD8\u4EAE\u80CC\u666F\u7684\u6DF1\u6D45 (0% - 100%)\u3002",
    settingDarkOpacityName: "\u6DF1\u8272\u6A21\u5F0F\u4E0D\u900F\u660E\u5EA6",
    settingDarkOpacityDesc: "\u8C03\u6574 Dark \u4E3B\u9898\u4E0B\u9AD8\u4EAE\u80CC\u666F\u7684\u6DF1\u6D45 (0% - 100%)\u3002",
    settingTooltipWidthName: "Tooltip \u6700\u5927\u5BBD\u5EA6",
    settingTooltipWidthDesc: "\u9650\u5236\u60AC\u6D6E\u6C14\u6CE1\u7684\u6700\u5927\u5BBD\u5EA6 (px)\u3002",
    settingFontAdjustName: "\u8C03\u8282\u5B57\u4F53\u5927\u5C0F",
    settingFontAdjustDescPrefix: "\u6279\u6CE8\u5185\u5BB9\u5B57\u4F53\u6309\u6863\u4F4D\u8C03\u6574\uFF08\u6700\u591A \xB13 \u6863\uFF09\u3002 \u5F53\u524D\uFF1A",
    settingFontStepDefault: "\u9ED8\u8BA4",
    settingFontStep: (step) => `${step > 0 ? "+" : ""}${step} \u6863`,
    settingFontStepPlural: (step) => `${step > 0 ? "+" : ""}${step} \u6863`,
    settingFontSmaller: "\u51CF\u5C0F\u4E00\u53F7",
    settingFontLarger: "\u52A0\u5927\u4E00\u53F7",
    settingMarkdownName: "\u542F\u7528 Markdown \u6E32\u67D3",
    settingMarkdownDesc: "\u5F00\u542F\u540E\uFF0C\u6279\u6CE8\u5185\u5BB9\u652F\u6301 Markdown\uFF1B\u5173\u95ED\u5219\u663E\u793A\u7EAF\u6587\u672C\u3002",
    settingFixDataName: "\u4E00\u952E\u4FEE\u590D\u6570\u636E",
    settingFixDataDesc: "\u626B\u63CF\u5E93\u4E2D\u6587\u4EF6\u5E76\u4FEE\u590D\u65E7\u7248\u6279\u6CE8\u7684\u683C\u5F0F\u95EE\u9898\u3002",
    settingFixDataButton: "\u5F00\u59CB\u626B\u63CF\u4FEE\u590D",
    settingExportName: "\u5BFC\u51FA\u6240\u6709\u6279\u6CE8\uFF08\u5F53\u524D\u6587\u4EF6\uFF09",
    settingExportDesc: "\u5C06\u5F53\u524D\u6587\u6863\u7684\u6240\u6709\u6279\u6CE8\u63D0\u53D6\u5230\u526A\u8D34\u677F\u3002",
    settingExportButton: "\u590D\u5236\u5230\u526A\u8D34\u677F",
    exportHeading: "## \u6279\u6CE8\u5BFC\u51FA\n\n",
    exportOriginal: "\u539F\u6587",
    exportAnnotation: "\u6279\u6CE8",
    menuAddTitle: "\u6DFB\u52A0\u6279\u6CE8"
  }
};
var COLOR_OPTIONS = [
  { value: "red", labelKey: "colorRed", hex: "#e5484d" },
  { value: "", labelKey: "colorDefault", hex: "#ff9900" },
  // Orange is default (empty class)
  { value: "yellow", labelKey: "colorYellow", hex: "#e6c229" },
  { value: "green", labelKey: "colorGreen", hex: "#2f9d62" },
  { value: "cyan", labelKey: "colorCyan", hex: "#1abc9c" },
  { value: "blue", labelKey: "colorBlue", hex: "#3498db" },
  { value: "purple", labelKey: "colorPurple", hex: "#9b59b6" },
  { value: "gray", labelKey: "colorGray", hex: "#95a5a6" }
];
var DEFAULT_SETTINGS = {
  defaultColor: DEFAULT_COLOR,
  hideAnnotations: false,
  enableUnderline: true,
  enableBackground: true,
  enableIcon: false,
  iconTooltipTrigger: "hover",
  lightOpacity: 20,
  darkOpacity: 25,
  tooltipWidth: 800,
  tooltipFontScale: 100,
  enableMarkdown: true,
  language: "en"
};
function buildAnnotationClass(color) {
  return color ? "ob-comment " + color : "ob-comment";
}
function escapeDataNote(note) {
  return note.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/`/g, "&#96;").replace(/\|/g, "&#124;").replace(/\r?\n/g, "&#10;");
}
function decodeDataNote(note) {
  return note.replace(/&#10;/g, "\n").replace(/&#13;/g, "\r").replace(/&#96;/g, "`").replace(/&#39;/g, "'").replace(/&quot;/g, '"').replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&#124;/g, "|").replace(/&amp;/g, "&");
}
function normalizeAnnotationsInText(text) {
  COMMENT_REGEX.lastIndex = 0;
  let result = "";
  let lastIndex = 0;
  let changed = false;
  let match;
  while ((match = COMMENT_REGEX.exec(text)) !== null) {
    const fullMatch = match[0];
    const colorClass = match[1] || "";
    const rawNote = match[2];
    const visibleText = match[3];
    const safeNote = escapeDataNote(decodeDataNote(rawNote));
    const replacement = `<span class="${buildAnnotationClass(colorClass)}" data-note="${safeNote}">${visibleText}</span>`;
    result += text.slice(lastIndex, match.index) + replacement;
    lastIndex = match.index + fullMatch.length;
    if (replacement !== fullMatch) changed = true;
  }
  result += text.slice(lastIndex);
  return { text: changed ? result : text, changed };
}
var _AnnotationPlugin = class _AnnotationPlugin extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.tooltipEl = null;
    this.locale = "en";
  }
  // 记忆上次使用的颜色
  t(key, params) {
    const entry = STRINGS[this.locale][key];
    if (typeof entry === "function") {
      return entry(params);
    }
    return entry;
  }
  getColorLabel(key) {
    return this.t(key);
  }
  getCommandRegistry() {
    var _a;
    return (_a = this.app.commands) == null ? void 0 : _a.commands;
  }
  setCommandName(id, name) {
    const registry = this.getCommandRegistry();
    if (!registry) return;
    const fullId = `${this.manifest.id}:${id}`;
    if (registry[fullId]) registry[fullId].name = name;
  }
  updateCommandNames() {
    this.setCommandName("add-annotation-html", this.t("cmdAddDefault"));
    COLOR_OPTIONS.forEach((opt) => {
      if (opt.value === "") return;
      const colorLabel = this.getColorLabel(opt.labelKey);
      this.setCommandName(`add-annotation-${opt.value}`, this.t("cmdAddWithColor", colorLabel));
    });
    this.setCommandName("toggle-annotation-visibility", this.t("cmdToggleVisibility"));
    this.setCommandName("edit-current-annotation", this.t("cmdEditCurrent"));
    this.setCommandName("delete-current-annotation", this.t("cmdDeleteCurrent"));
    this.setCommandName("normalize-annotation-data-note-current", this.t("cmdNormalizeCurrent"));
    this.setCommandName("normalize-annotation-data-note-vault", this.t("cmdNormalizeVault"));
  }
  async onload() {
    var _a;
    await this.loadSettings();
    this.locale = (_a = this.settings.language) != null ? _a : "en";
    _AnnotationPlugin.lastUsedColor = this.settings.defaultColor;
    this.updateStyles();
    this.addSettingTab(new AnnotationSettingTab(this.app, this));
    COLOR_OPTIONS.forEach((opt) => {
      const iconId = opt.value ? `ob-annotation-icon-${opt.value}` : `ob-annotation-icon-default`;
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="66" height="66" viewBox="0 0 24 24" style="overflow: visible"><circle cx="12" cy="20" r="10" style="fill:${opt.hex};stroke:${opt.hex};stroke-width:1;" /></svg>`;
      (0, import_obsidian.addIcon)(iconId, svg);
    });
    this.addCommand({
      id: "add-annotation-html",
      name: this.t("cmdAddDefault"),
      editorCallback: (editor, view) => {
        this.handleAddCommand(editor);
      }
    });
    COLOR_OPTIONS.forEach((opt) => {
      if (opt.value === "") return;
      const colorLabel = this.getColorLabel(opt.labelKey);
      this.addCommand({
        id: `add-annotation-${opt.value}`,
        name: this.t("cmdAddWithColor", colorLabel),
        editorCallback: (editor) => {
          this.handleAddCommand(editor, opt.value);
        }
      });
    });
    this.addCommand({
      id: "toggle-annotation-visibility",
      name: this.t("cmdToggleVisibility"),
      callback: async () => {
        this.settings.hideAnnotations = !this.settings.hideAnnotations;
        this.updateStyles();
        await this.saveSettings();
        if (this.settings.hideAnnotations) {
          new import_obsidian.Notice(this.t("noticeHidden"));
        } else {
          new import_obsidian.Notice(this.t("noticeShown"));
        }
      }
    });
    this.addCommand({
      id: "edit-current-annotation",
      name: this.t("cmdEditCurrent"),
      editorCallback: (editor) => {
        this.handleEditCommand(editor);
      }
    });
    this.addCommand({
      id: "delete-current-annotation",
      name: this.t("cmdDeleteCurrent"),
      editorCallback: (editor) => {
        this.handleDeleteCommand(editor);
      }
    });
    this.addCommand({
      id: "normalize-annotation-data-note-current",
      name: this.t("cmdNormalizeCurrent"),
      editorCallback: async (editor) => {
        await this.normalizeCurrentFileAnnotations(editor);
      }
    });
    this.addCommand({
      id: "normalize-annotation-data-note-vault",
      name: this.t("cmdNormalizeVault"),
      callback: async () => {
        await this.normalizeAllMarkdownFiles();
      }
    });
    this.registerEditorExtension(livePreviewAnnotationPlugin);
    this.createTooltipElement();
    this.registerDomEvent(document, "mouseover", (evt) => {
      if (document.body.classList.contains("ob-hide-annotations")) return;
      const target = evt.target;
      if (this.shouldShowTooltipOnHover(evt, target)) {
        const note = target.getAttribute("data-note");
        if (note) this.showTooltip(evt, note);
      }
    });
    this.registerDomEvent(document, "mousemove", (evt) => {
      if (!this.isIconOnlyMode()) return;
      if (this.settings.iconTooltipTrigger !== "hover") return;
      if (document.body.classList.contains("ob-hide-annotations")) return;
      const target = evt.target;
      if (target && target.hasClass && target.hasClass("ob-comment")) {
        const note = target.getAttribute("data-note");
        if (note && this.isEventOnIcon(evt, target)) {
          this.showTooltip(evt, note);
          return;
        }
      }
      this.hideTooltip();
    });
    this.registerDomEvent(document, "mouseout", (evt) => {
      const target = evt.target;
      if (target && target.hasClass && target.hasClass("ob-comment")) {
        this.hideTooltip();
      }
    });
    this.registerDomEvent(document, "click", (evt) => {
      if (document.body.classList.contains("ob-hide-annotations")) return;
      const target = evt.target;
      if (target && target.hasClass && target.hasClass("ob-comment")) {
        if (this.shouldShowTooltipOnClick(evt, target)) {
          const note = target.getAttribute("data-note");
          if (note) this.showTooltip(evt, note);
        }
      } else {
        if (this.tooltipEl && !this.tooltipEl.contains(target)) {
          this.hideTooltip();
        }
      }
    });
    this.registerDomEvent(document, "mousedown", (evt) => {
      const target = evt.target;
      if (target && target.hasClass && target.hasClass("ob-comment")) {
        return;
      }
      this.hideTooltip();
    });
    this.registerDomEvent(document, "keydown", () => {
      this.hideTooltip();
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor, view) => {
        this.handleContextMenu(menu, editor);
      })
    );
  }
  onunload() {
    if (this.tooltipEl) {
      this.tooltipEl.remove();
    }
    document.body.classList.remove("ob-show-underline", "ob-show-background", "ob-show-icon", "ob-hide-annotations", "ob-icon-only-mode");
    const rootStyle = document.documentElement.style;
    rootStyle.removeProperty("--ob-annotation-bg-opacity-light");
    rootStyle.removeProperty("--ob-annotation-bg-opacity-dark");
    rootStyle.removeProperty("--ob-annotation-tooltip-width");
    rootStyle.removeProperty("--ob-annotation-tooltip-font-scale");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isIconOnlyMode() {
    return this.settings.enableIcon && !this.settings.enableUnderline && !this.settings.enableBackground;
  }
  isEventOnIcon(evt, target) {
    const rects = target.getClientRects();
    if (!rects.length) return false;
    const lastRect = rects[rects.length - 1];
    const style = getComputedStyle(target, "::after");
    const iconWidth = parseFloat(style.width || "") || 14;
    const iconMarginLeft = parseFloat(style.marginLeft || "") || 2;
    const hitboxStartX = lastRect.right - iconWidth - iconMarginLeft;
    const x = evt.clientX;
    const y = evt.clientY;
    return x >= hitboxStartX && x <= lastRect.right && y >= lastRect.top && y <= lastRect.bottom;
  }
  shouldShowTooltipOnHover(evt, target) {
    if (!target || !target.hasClass || !target.hasClass("ob-comment")) return false;
    if (this.isIconOnlyMode()) {
      if (this.settings.iconTooltipTrigger !== "hover") return false;
      return this.isEventOnIcon(evt, target);
    }
    return true;
  }
  shouldShowTooltipOnClick(evt, target) {
    if (!target || !target.hasClass || !target.hasClass("ob-comment")) return false;
    if (this.isIconOnlyMode()) {
      return this.isEventOnIcon(evt, target);
    }
    return true;
  }
  /**
   * 根据当前设置更新全局样式（body class + CSS 变量），即时生效。
   */
  updateStyles() {
    var _a, _b;
    const iconOnlyMode = this.isIconOnlyMode();
    document.body.classList.toggle("ob-show-underline", this.settings.enableUnderline);
    document.body.classList.toggle("ob-show-background", this.settings.enableBackground);
    document.body.classList.toggle("ob-show-icon", this.settings.enableIcon);
    document.body.classList.toggle("ob-hide-annotations", this.settings.hideAnnotations);
    document.body.classList.toggle("ob-icon-only-mode", iconOnlyMode);
    const clampOpacity = (value) => Math.min(Math.max(value, 0), 100) / 100;
    const rootStyle = document.documentElement.style;
    const lightAlpha = clampOpacity((_a = this.settings.lightOpacity) != null ? _a : DEFAULT_SETTINGS.lightOpacity);
    const darkAlpha = clampOpacity((_b = this.settings.darkOpacity) != null ? _b : DEFAULT_SETTINGS.darkOpacity);
    const tooltipWidth = this.settings.tooltipWidth > 0 ? this.settings.tooltipWidth : DEFAULT_SETTINGS.tooltipWidth;
    const fontScale = this.settings.tooltipFontScale > 0 ? this.settings.tooltipFontScale : DEFAULT_SETTINGS.tooltipFontScale;
    rootStyle.setProperty("--ob-annotation-bg-opacity-light", lightAlpha.toString());
    rootStyle.setProperty("--ob-annotation-bg-opacity-dark", darkAlpha.toString());
    rootStyle.setProperty("--ob-annotation-tooltip-width", `${tooltipWidth}px`);
    rootStyle.setProperty("--ob-annotation-tooltip-font-scale", `${fontScale / 100}`);
  }
  // --- 核心逻辑区 ---
  /**
   * 命令触发：编辑当前批注
   */
  handleEditCommand(editor) {
    const existing = this.findAnnotationAtCursor(editor);
    if (existing) {
      new AnnotationModal(this.app, existing.note, existing.color || DEFAULT_COLOR, (newNote, newColor) => {
        const safeNote = escapeDataNote(newNote);
        const replacement = `<span class="${buildAnnotationClass(newColor)}" data-note="${safeNote}">${existing.text}</span>`;
        editor.replaceRange(replacement, existing.from, existing.to);
      }, this.locale, this.t.bind(this)).open();
    } else {
      new import_obsidian.Notice(this.t("noticeNoAnnotation"));
    }
  }
  /**
   * 命令触发：删除当前批注
   */
  handleDeleteCommand(editor) {
    const existing = this.findAnnotationAtCursor(editor);
    if (existing) {
      editor.replaceRange(existing.text, existing.from, existing.to);
    } else {
      new import_obsidian.Notice(this.t("noticeNoAnnotation"));
    }
  }
  /**
   * 处理右键菜单逻辑
   */
  handleContextMenu(menu, editor) {
    const existingAnnotation = this.findAnnotationAtCursor(editor);
    if (existingAnnotation) {
      menu.addSeparator();
      menu.addItem((item) => {
        item.setTitle(this.t("ctxAdd")).setIcon("highlighter").onClick(() => {
          const selection = editor.getSelection();
          if (selection) this.performAddAnnotation(editor, selection);
          else new import_obsidian.Notice(this.t("noticeNeedSelectionAdd"));
        });
      });
      menu.addItem((item) => {
        item.setTitle(this.t("ctxEdit")).setIcon("pencil").onClick(() => {
          this.handleEditCommand(editor);
        });
      });
      menu.addItem((item) => {
        item.setTitle(this.t("ctxChangeColor")).setIcon("palette");
        if (item.setSubmenu) {
          const subMenu = item.setSubmenu();
          COLOR_OPTIONS.forEach((opt) => {
            const iconId = opt.value ? `ob-annotation-icon-${opt.value}` : `ob-annotation-icon-default`;
            const colorLabel = this.getColorLabel(opt.labelKey);
            subMenu.addItem((subItem) => {
              subItem.setTitle(colorLabel).setIcon(iconId).onClick(() => {
                const replacement = `<span class="${buildAnnotationClass(opt.value)}" data-note="${escapeDataNote(existingAnnotation.note)}">${existingAnnotation.text}</span>`;
                editor.replaceRange(replacement, existingAnnotation.from, existingAnnotation.to);
              });
            });
          });
        }
      });
      menu.addItem((item) => {
        item.setTitle(this.t("ctxDelete")).setIcon("trash").onClick(() => {
          this.handleDeleteCommand(editor);
        });
      });
    } else {
      const selection = editor.getSelection();
      if (selection && selection.trim().length > 0) {
        menu.addSeparator();
        menu.addItem((item) => {
          item.setTitle(this.t("ctxAdd")).setIcon("highlighter").onClick(() => {
            this.performAddAnnotation(editor, selection);
          });
        });
      }
    }
  }
  /**
   * 命令触发的添加逻辑
   */
  handleAddCommand(editor, forcedColor = null) {
    const selection = editor.getSelection();
    if (!selection) {
      new import_obsidian.Notice(this.t("noticeNeedSelection"));
      return;
    }
    if (selection.includes('<span class="ob-comment"')) {
      new import_obsidian.Notice(this.t("noticeNoNested"));
      return;
    }
    this.performAddAnnotation(editor, selection, forcedColor);
  }
  /**
   * 执行添加批注动作
   */
  performAddAnnotation(editor, selectionText, forcedColor = null) {
    const initialColor = forcedColor !== null ? forcedColor : _AnnotationPlugin.lastUsedColor;
    new AnnotationModal(this.app, "", initialColor, (noteContent, colorChoice) => {
      _AnnotationPlugin.lastUsedColor = colorChoice;
      const safeNote = escapeDataNote(noteContent);
      const replacement = `<span class="${buildAnnotationClass(colorChoice)}" data-note="${safeNote}">${selectionText}</span>`;
      editor.replaceSelection(replacement);
    }, this.locale, this.t.bind(this)).open();
  }
  /**
   * [辅助算法] 扫描全文，判断光标是否位于某个批注 HTML 标签内部
   */
  findAnnotationAtCursor(editor) {
    const cursor = editor.getCursor();
    const cursorOffset = editor.posToOffset(cursor);
    const docText = editor.getValue();
    COMMENT_REGEX.lastIndex = 0;
    let match;
    while ((match = COMMENT_REGEX.exec(docText)) !== null) {
      const fullMatch = match[0];
      const colorClass = match[1] || "";
      const noteContent = match[2];
      const innerText = match[3];
      const startOffset = match.index;
      const endOffset = startOffset + fullMatch.length;
      if (cursorOffset >= startOffset && cursorOffset <= endOffset) {
        return {
          from: editor.offsetToPos(startOffset),
          to: editor.offsetToPos(endOffset),
          text: innerText,
          // 原文
          note: decodeDataNote(noteContent),
          // 笔记内容（解码后）
          color: colorClass
        };
      }
    }
    return null;
  }
  // --- Tooltip 相关逻辑 (保持不变) ---
  createTooltipElement() {
    this.tooltipEl = document.body.createDiv({ cls: "ob-annotation-tooltip" });
  }
  showTooltip(evt, text) {
    var _a;
    if (!this.tooltipEl) return;
    this.tooltipEl.empty();
    const decodedText = decodeDataNote(text);
    const sourcePath = ((_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) || "";
    if (this.settings.enableMarkdown) {
      import_obsidian.MarkdownRenderer.render(this.app, decodedText, this.tooltipEl, sourcePath, this);
    } else {
      const pre = this.tooltipEl.createEl("pre", { text: decodedText });
      pre.style.margin = "0";
      pre.style.whiteSpace = "pre-wrap";
    }
    this.tooltipEl.addClass("is-visible");
    const x = evt.pageX;
    const y = evt.pageY - 40;
    this.tooltipEl.style.left = `${x}px`;
    this.tooltipEl.style.top = `${y}px`;
  }
  hideTooltip() {
    if (!this.tooltipEl) return;
    this.tooltipEl.removeClass("is-visible");
  }
  /**
   * 修复当前文件中所有批注的 data-note（处理旧版直接换行/特殊字符未转义的情况）
   */
  async normalizeCurrentFileAnnotations(editor) {
    const docText = editor.getValue();
    const { text, changed } = normalizeAnnotationsInText(docText);
    if (!changed) {
      new import_obsidian.Notice(this.t("noticeNoFixNeeded"));
      return;
    }
    const cursor = editor.getCursor();
    const lastLine = editor.lastLine();
    const lastLineLen = editor.getLine(lastLine).length;
    editor.replaceRange(text, { line: 0, ch: 0 }, { line: lastLine, ch: lastLineLen });
    editor.setCursor(cursor);
    new import_obsidian.Notice(this.t("noticeFixedCurrent"));
  }
  /**
   * 扫描并修复库内所有 Markdown 文件的批注 data-note
   */
  async normalizeAllMarkdownFiles() {
    new import_obsidian.Notice(this.t("noticeScanStart"));
    const files = this.app.vault.getMarkdownFiles();
    const filesToFix = [];
    for (const file of files) {
      const original = await this.app.vault.read(file);
      const { changed } = normalizeAnnotationsInText(original);
      if (changed) {
        filesToFix.push(file);
      }
    }
    if (filesToFix.length === 0) {
      new import_obsidian.Notice(this.t("noticeNoFixNeeded"));
      return;
    }
    new BatchFixConfirmModal(this.app, filesToFix, async () => {
      let fixedCount = 0;
      for (const file of filesToFix) {
        const original = await this.app.vault.read(file);
        const { text, changed } = normalizeAnnotationsInText(original);
        if (changed) {
          await this.app.vault.modify(file, text);
          fixedCount++;
        }
      }
      new import_obsidian.Notice(this.t("noticeFixedVault", fixedCount));
    }, this.t.bind(this)).open();
  }
};
_AnnotationPlugin.lastUsedColor = DEFAULT_COLOR;
var AnnotationPlugin = _AnnotationPlugin;
var AnnotationSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let iconTriggerSetting = null;
    const t = this.plugin.t.bind(this.plugin);
    containerEl.createEl("h2", { text: t("settingsGeneral") });
    new import_obsidian.Setting(containerEl).setName(t("settingLanguageName")).setDesc(t("settingLanguageDesc")).addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("en", t("settingLanguageEn"));
      dropdown.addOption("zh", t("settingLanguageZh"));
      dropdown.setValue((_a = this.plugin.settings.language) != null ? _a : "en").onChange(async (value) => {
        const nextLocale = value === "zh" ? "zh" : "en";
        this.plugin.settings.language = nextLocale;
        this.plugin.locale = nextLocale;
        await this.plugin.saveSettings();
        this.plugin.updateCommandNames();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settingDefaultColorName")).setDesc(t("settingDefaultColorDesc")).addDropdown((dropdown) => {
      COLOR_OPTIONS.forEach((opt) => {
        dropdown.addOption(opt.value, t(opt.labelKey));
      });
      dropdown.setValue(this.plugin.settings.defaultColor).onChange(async (value) => {
        this.plugin.settings.defaultColor = value;
        AnnotationPlugin.lastUsedColor = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settingHideDefaultName")).setDesc(t("settingHideDefaultDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.hideAnnotations).onChange(async (value) => {
      this.plugin.settings.hideAnnotations = value;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: t("settingsAppearance") });
    new import_obsidian.Setting(containerEl).setName(t("settingUnderlineName")).setDesc(t("settingUnderlineDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableUnderline).onChange(async (value) => {
      this.plugin.settings.enableUnderline = value;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(t("settingBackgroundName")).setDesc(t("settingBackgroundDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableBackground).onChange(async (value) => {
      this.plugin.settings.enableBackground = value;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(t("settingIconName")).setDesc(t("settingIconDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableIcon).onChange(async (value) => {
      this.plugin.settings.enableIcon = value;
      this.plugin.updateStyles();
      if (iconTriggerSetting) {
        iconTriggerSetting.setDisabled(!value);
      }
      await this.plugin.saveSettings();
    }));
    iconTriggerSetting = new import_obsidian.Setting(containerEl).setName(t("settingIconTriggerName")).setDesc(t("settingIconTriggerDesc")).addDropdown((dropdown) => {
      dropdown.addOption("hover", t("settingIconHover"));
      dropdown.addOption("click", t("settingIconClick"));
      dropdown.setValue(this.plugin.settings.iconTooltipTrigger).onChange(async (value) => {
        const nextValue = value === "click" ? "click" : "hover";
        this.plugin.settings.iconTooltipTrigger = nextValue;
        await this.plugin.saveSettings();
      });
    }).setDisabled(!this.plugin.settings.enableIcon);
    new import_obsidian.Setting(containerEl).setName(t("settingLightOpacityName")).setDesc(t("settingLightOpacityDesc")).addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.lightOpacity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.lightOpacity = value;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName(t("settingDarkOpacityName")).setDesc(t("settingDarkOpacityDesc")).addSlider((slider) => slider.setLimits(0, 100, 5).setValue(this.plugin.settings.darkOpacity).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.darkOpacity = value;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: t("settingsInteraction") });
    new import_obsidian.Setting(containerEl).setName(t("settingTooltipWidthName")).setDesc(t("settingTooltipWidthDesc")).addText((text) => text.setPlaceholder("800").setValue(this.plugin.settings.tooltipWidth.toString()).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num)) {
        this.plugin.settings.tooltipWidth = num;
        this.plugin.updateStyles();
        await this.plugin.saveSettings();
      }
    }));
    const fontStepSize = 10;
    const fontStepMax = 3;
    const clampStep = (val) => Math.min(Math.max(val, -fontStepMax), fontStepMax);
    const getCurrentStep = () => {
      var _a;
      const base = DEFAULT_SETTINGS.tooltipFontScale;
      const current = (_a = this.plugin.settings.tooltipFontScale) != null ? _a : base;
      return clampStep(Math.round((current - base) / fontStepSize));
    };
    const formatStepLabel = (step) => {
      if (step === 0) return t("settingFontStepDefault");
      const abs = Math.abs(step);
      if (abs === 1) return t("settingFontStep", step);
      return t("settingFontStepPlural", step);
    };
    const fontSizeSetting = new import_obsidian.Setting(containerEl).setName(t("settingFontAdjustName"));
    fontSizeSetting.descEl.empty();
    fontSizeSetting.descEl.createSpan({ text: t("settingFontAdjustDescPrefix") });
    const fontStepLabelEl = fontSizeSetting.descEl.createSpan({ text: formatStepLabel(getCurrentStep()) });
    const applyFontStep = async (delta) => {
      const base = DEFAULT_SETTINGS.tooltipFontScale;
      const nextStep = clampStep(getCurrentStep() + delta);
      const nextScale = base + nextStep * fontStepSize;
      this.plugin.settings.tooltipFontScale = nextScale;
      this.plugin.updateStyles();
      await this.plugin.saveSettings();
      fontStepLabelEl.setText(formatStepLabel(nextStep));
    };
    fontSizeSetting.addButton((button) => {
      button.setButtonText(t("settingFontSmaller"));
      button.onClick(async () => {
        await applyFontStep(-1);
      });
    });
    fontSizeSetting.addButton((button) => {
      button.setButtonText(t("settingFontLarger"));
      button.setCta();
      button.onClick(async () => {
        await applyFontStep(1);
      });
    });
    new import_obsidian.Setting(containerEl).setName(t("settingMarkdownName")).setDesc(t("settingMarkdownDesc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMarkdown).onChange(async (value) => {
      this.plugin.settings.enableMarkdown = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: t("settingsAdvanced") });
    new import_obsidian.Setting(containerEl).setName(t("settingFixDataName")).setDesc(t("settingFixDataDesc")).addButton((button) => button.setButtonText(t("settingFixDataButton")).onClick(async () => {
      await this.plugin.normalizeAllMarkdownFiles();
    }));
    new import_obsidian.Setting(containerEl).setName(t("settingExportName")).setDesc(t("settingExportDesc")).addButton((button) => button.setButtonText(t("settingExportButton")).onClick(async () => {
      const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        const text = view.editor.getValue();
        const regex = /<span class="ob-comment(?:\s+[\w-]+)?" data-note="([\s\S]*?)">([\s\S]*?)<\/span>/g;
        let match;
        let output = this.plugin.t("exportHeading");
        while ((match = regex.exec(text)) !== null) {
          const note = decodeDataNote(match[1]);
          const original = match[2];
          output += `- **${this.plugin.t("exportOriginal")}**: "${original}"
  - **${this.plugin.t("exportAnnotation")}**: ${note}
`;
        }
        await navigator.clipboard.writeText(output);
        new import_obsidian.Notice(this.plugin.t("noticeCopied"));
      } else {
        new import_obsidian.Notice(this.plugin.t("noticeOpenDoc"));
      }
    }));
  }
};
var AnnotationModal = class extends import_obsidian.Modal {
  constructor(app, defaultValue, defaultColor, onSubmit, locale, translate) {
    super(app);
    this.colorLabelEl = null;
    this.defaultValue = defaultValue;
    this.defaultColor = defaultColor;
    this.selectedColor = defaultColor || DEFAULT_COLOR;
    this.onSubmit = onSubmit;
    this.locale = locale;
    this.translate = translate;
    this.modalEl.addClass("ob-annotation-modal-container");
  }
  onOpen() {
    const { contentEl } = this;
    const headerRow = contentEl.createDiv({ cls: "annotation-header-row" });
    headerRow.createEl("h2", { text: this.defaultValue ? this.translate("modalTitleEdit") : this.translate("modalTitleNew") });
    headerRow.createDiv({
      cls: "annotation-key-hint",
      text: this.translate("modalKeyHint")
    });
    const inputEl = contentEl.createEl("textarea", {
      cls: "annotation-input",
      attr: { rows: "3", style: "width: 100%; margin-bottom: 10px;" }
    });
    const adjustHeight = () => {
      inputEl.style.height = "auto";
      inputEl.style.height = inputEl.scrollHeight + "px";
    };
    inputEl.addEventListener("input", adjustHeight);
    inputEl.value = this.defaultValue;
    setTimeout(() => {
      adjustHeight();
      inputEl.focus();
      if (this.defaultValue) inputEl.select();
    }, 0);
    const colorWrapper = contentEl.createDiv({ cls: "annotation-color-field" });
    const colorHeader = colorWrapper.createDiv({
      cls: "setting-item-name",
      attr: { style: "margin-bottom: 8px; font-weight: bold; display: flex; justify-content: space-between; align-items: center;" }
    });
    colorHeader.createSpan({ text: this.translate("modalColorLabel") });
    this.colorLabelEl = colorHeader.createSpan({
      cls: "annotation-color-label",
      attr: { style: "font-weight: normal; font-size: 0.9em; color: var(--text-muted);" }
    });
    const colorRow = colorWrapper.createDiv({ cls: "annotation-color-row" });
    const colorContainer = colorRow.createDiv({ cls: "annotation-color-container" });
    const btnContainer = colorRow.createDiv({ cls: "modal-button-container inline" });
    COLOR_OPTIONS.forEach((opt) => {
      const colorLabel = this.translate(opt.labelKey);
      const colorItem = colorContainer.createDiv({
        cls: "annotation-color-item",
        attr: { "aria-label": colorLabel, "title": colorLabel, "tabindex": "0" }
        // 支持键盘 Tab 聚焦
      });
      colorItem.style.backgroundColor = opt.hex;
      if (opt.value === this.selectedColor) {
        colorItem.addClass("is-active");
        this.updateColorLabel(colorLabel);
      }
      const selectAction = () => {
        colorContainer.querySelectorAll(".annotation-color-item").forEach((el) => el.removeClass("is-active"));
        colorItem.addClass("is-active");
        this.selectedColor = opt.value;
        this.updateColorLabel(colorLabel);
      };
      colorItem.addEventListener("click", selectAction);
      colorItem.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          selectAction();
        }
      });
    });
    inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && e.shiftKey) {
        return;
      }
      if (e.key === "Enter") {
        e.preventDefault();
        this.submit(inputEl.value);
      }
    });
    const cancelBtn = btnContainer.createEl("button", { text: this.translate("modalCancel") });
    cancelBtn.addEventListener("click", () => this.close());
    const submitBtn = btnContainer.createEl("button", { text: this.translate("modalConfirm"), cls: "mod-cta" });
    submitBtn.addEventListener("click", () => {
      this.submit(inputEl.value);
    });
  }
  updateColorLabel(label) {
    if (this.colorLabelEl) {
      this.colorLabelEl.setText(`${this.translate("modalColorCurrent")}${label}`);
    }
  }
  submit(value) {
    this.onSubmit(value, this.selectedColor);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BatchFixConfirmModal = class extends import_obsidian.Modal {
  constructor(app, filesToFix, onConfirm, translate) {
    super(app);
    this.filesToFix = filesToFix;
    this.onConfirm = onConfirm;
    this.translate = translate;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.translate("batchTitle") });
    contentEl.createEl("p", {
      text: this.translate("batchSummary", this.filesToFix.length)
    });
    contentEl.createEl("p", {
      text: this.translate("batchWarning"),
      cls: "mod-warning"
    });
    const btnContainer = contentEl.createDiv({ cls: "modal-button-container", attr: { style: "display: flex; justify-content: flex-end; gap: 10px;" } });
    const cancelBtn = btnContainer.createEl("button", { text: this.translate("batchCancel") });
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = btnContainer.createEl("button", { text: this.translate("batchConfirm", this.filesToFix.length), cls: "mod-cta" });
    confirmBtn.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};
var livePreviewAnnotationPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    const text = view.state.doc.toString();
    const selection = view.state.selection.main;
    const cursorFrom = selection.from;
    const cursorTo = selection.to;
    let match;
    COMMENT_REGEX.lastIndex = 0;
    while ((match = COMMENT_REGEX.exec(text)) !== null) {
      const fullMatch = match[0];
      const colorClass = match[1] || "";
      const noteContent = match[2];
      const visibleText = match[3];
      const noteText = decodeDataNote(noteContent);
      const startPos = match.index;
      const endPos = startPos + fullMatch.length;
      const openingTagLength = fullMatch.indexOf(">") + 1;
      const openingTagFrom = startPos;
      const openingTagTo = startPos + openingTagLength;
      const contentFrom = openingTagTo;
      const contentTo = contentFrom + visibleText.length;
      const closingTagFrom = contentTo;
      const closingTagTo = endPos;
      const isCursorInside = cursorFrom >= startPos && cursorFrom <= endPos || cursorTo >= startPos && cursorTo <= endPos;
      if (isCursorInside) continue;
      builder.add(openingTagFrom, openingTagTo, import_view.Decoration.replace({}));
      builder.add(contentFrom, contentTo, import_view.Decoration.mark({
        class: buildAnnotationClass(colorClass),
        attributes: { "data-note": noteText }
      }));
      builder.add(closingTagFrom, closingTagTo, import_view.Decoration.replace({}));
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
